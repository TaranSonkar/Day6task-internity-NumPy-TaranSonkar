# -*- coding: utf-8 -*-
"""Day6task

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aNP92CHzk1rU2kIcw1qRcq_3KhnEKIBW
"""

#What is NumPy
'''NumPy is a Python library used for working with arrays. 
It also has functions for working in domain of linear algebra, fourier transform, and matrices. 
NumPy was created in 2005 by Travis Oliphant. It is an open source project and you can use it freely.'''

#array=homogenious
#list =hetrogenious

#why NumPy arrays

'''python has for handling such numerical array the numpy package and pandas package
2-- numpy array like python built in list type
3--numpy arrays provide much more efficient storage and data opretion as the array
go larger in size.
4--data deriving size and computation requireds understanding how to data stored an menupulated'''

#Limitation of numpy

'''The focus of NumPy is working with numerical data. Itâ€™s both: powerful and low-level (it provides basic functionality for high-level algorithms).
 If you enter the machine learning and data science space, you want to master numpy first. 
 But eventually, you will use other libraries that operate on a higher level such as Tensorflow and scikit-learn. 
 Those libraries contain out-of-the-box machine learning functions such as training and inference algorithms. Have a look at them after reading this tutorial.
If you enter mathematical areas that are not close to linear algebra, you may want to shift your focus to other libraries that better suit your needs. 
Examples are matplotlib and pyqtgraph.'''

#installation of numpy

'''install numpy'''

#open cmd
#write >pip install numpy

#installing numpy on server

#server name anaconda
#open cmd
#>conda install -c annconda numpy
#########################################################################################

import numpy as np
np.array

#numpy object
'''The most important object defined in NumPy is an N-dimensional array type called ndarray. 
It describes the collection of items of the same type.
Items in the collection can be accessed using a zero-based index.

Every item in an ndarray takes the same size of block in the memory.
Each element in ndarray is an object of data-type object (called dtype)'''


np.array
np.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)
#output---array(<class 'object'>, dtype=object)

#ex--

a = np.array([1,2,3]) 
a

#output--array([1, 2, 3])

###################################################################################################

#how to check version of numpy

print(np.__version__)

#1.19.5

# One d array

a = np.array([1,2,3]) 
a

#output--array([1, 2, 3])

#2d array

a=np.array([[1,2,3],[4,5,6]])
a 

#output--array([[1, 2, 3],[4, 5, 6]])

###################################################################################

#Array indexing and slicing

a = np.arange(10)
a

#output--array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

a[5]

#output--5

a[0]

#output--0

a[1:8]

#output--array([1, 2, 3, 4, 5, 6, 7])

a[:]

#output----array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

a[::2]

#output--array([0, 2, 4, 6, 8])

a2 = np.arange(11)
a2

#output--array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])

a2[:3]=11
a2

#output--array([ 11, 11, 11,  3,  4,  5,  6,  7,  8,  9, 10])

a2[:] = 22
a2

#output--array([22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22])

a1 = np.arange(10)
a1

#output--array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

c = a1.copy()
c

#output--array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

##########################################################################################################

#Memory Layout of array

x = np.random.random((100, 100))

x.flags
#output--C_CONTIGUOUS : True
'''F_CONTIGUOUS : False
OWNDATA : True
WRITEABLE : True
ALIGNED : True
WRITEBACKIFCOPY : False
UPDATEIFCOPY : False'''

#The flags attribute holds information about the memory layout of the array.

#################################################################################################################################

#view and copies

'''The main difference between a copy and a view of an array is that the copy is a new array, and the view is just a view of the original array.

The copy owns the data and any changes made to the copy will not affect original array, and any changes made to the original array will not affect the copy.

The view does not own the data and any changes made to the view will affect the original array, and any changes made to the original array will affect the view.'''

#copies

arr = np.array([1, 2, 3, 4, 5]) #np.random.random((20,30))
x = arr.copy()
arr[0] = 42

print(arr)
print(x)

#output--
'''[42  2  3  4  5]
[1 2 3 4 5]'''

###########################################################################################################

#view
#Make a view, change the original array, and display both arrays

a = np.array([1, 2, 3, 4, 5])
x = a.view()
arr[0] = 42

print(a)
print(x)

#output--[1 2 3 4 5]
#[1 2 3 4 5]

############################################################################################################

#Creating ndarrays in numpy
#np.array(), np.arange(), np.ones(), np.zeros(), np.full(), np.empty(), np.eye() / identity()

data = [1,2,3,4,5]
a1 = np.array(data)
a1

#output--array([1, 2, 3, 4, 5])

type(a1)

#output=numpy.ndarray

data = [[1,2,3],[4,5,6]]
a1 = np.array(data)
a1

#output--array([[1, 2, 3],
#[4, 5, 6]])

data = [[1,2,3],[4,5,6]]
a1 = np.array(data, dtype = np.float64)
a1

#output--array([[1., 2., 3.],
#[4., 5., 6.]])

a1.shape

#output--(2,3)

a1.dtype

#output--dtype('float64')

a1.ndim #array count like 2

#output-2

a1 = np.arange(10)
a1

#output--array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

type(a1)
#numpy.ndarray

np.ones((2,3))
#2 x 3 matrix all in one

#output--
#array([[1., 1., 1.],
#[1., 1., 1.]])

np.zeros((3,3))

#output
'''array([[0., 0., 0.],
[0., 0., 0.],
[0., 0., 0.]])'''

np.full((2,3), fill_value = 10)

#output---
#array([[10, 10, 10],
#[10, 10, 10]])

np.empty(5)

#output---
#array([4.6888646e-310, 0.0000000e+000, 0.0000000e+000, 0.0000000e+000,
#0.0000000e+000])

np.eye(5)
#eye is identy matrix
#output--
'''array([[1., 0., 0., 0., 0.],
[0., 1., 0., 0., 0.],
[0., 0., 1., 0., 0.],
[0., 0., 0., 1., 0.],
[0., 0., 0., 0., 1.]])'''

##########################################################################################################

#Data Types in numpy

#int(8,16,32,64),uint(8,16,32,64), float(16,32,64,128), complex(64,128,256), bool, object, string_, unicode_

np.arange(5, dtype = np.int32)

#array([0, 1, 2, 3, 4], dtype=int32)

np.arange(5, dtype = np.float64)

#array([0., 1., 2., 3., 4.])

a = np.array([1, 2.5,3.8])
b = a.astype(np.int32)
b

#array([1, 2, 3], dtype=int32)

np.arange(5, dtype = np.complex64)

#array([0.+0.j, 1.+0.j, 2.+0.j, 3.+0.j, 4.+0.j], dtype=complex64)

np.arange(5, dtype = np.uint64)

#array([0, 1, 2, 3, 4], dtype=uint64)

######################################################################################################################

                            #Day6task completed--internity-----Taran Sonkar

#Date--14/June/2021
